



## 浏览器渲染页面的原理及流程

1.根据html文件构建DOM树和CSSOM树。构建DOM树期间，如果遇到JS，阻塞DOM树及CSSOM树的构建，优先加载JS文件，加载完毕，再继续构建DOM树及CSSOM树。

2.构建渲染树（Render Tree）。

3.页面的重绘（repaint）与重排（reflow，也有称回流）。页面渲染完成后，若JS操作了DOM节点，根据JS对DOM操作动作的大小，浏览器对页面进行重绘或是重排。

## DOM树和渲染树的区别

html经过解析生成DOM树；css经过解析生成style rules。两者结合生成了渲染树render tree。通过layout计算出DOM要显示的宽高、位置、颜色，最后渲染。

浏览器的渲染过程：

- 解析HTML构建DOM（DOM树），并行请求css/image/js
- css文件下载完成，开始构建CSSOM(CSS树)
- CSSOM构建结束后，和DOM一起生成render tree
- 布局（layout）:计算出每个节点在屏幕中的位置
- 显示（Painting）:通过显卡吧页面画到屏幕上

**DOM树和渲染树的区别**

- DOM树与HTML标签一一对应，包括head和隐藏元素
- 渲染树不包括head和隐藏元素，大段文本的每一行都是独立的节点，每个节点都有对应的css属性



## css会阻塞dom解析吗？

对于一个HTML文档来说，不管是内联还是外链的css，都会阻碍后续的dom渲染，但是不会阻碍后续dom的解析。

当css文件放在中时，虽然css解析也会阻塞后续dom的渲染，但是在解析css的同时也在解析dom，所以等到css解析完毕就会逐步的渲染页面了。

## 

## 重绘和回流(重排)的区别和关系？

- 重绘：渲染树中的元素外观（颜色）发生改变，不影响布局时，产生重绘。
- 回流：渲染树中元素的布局（尺寸、位置、隐藏）发生改变，产生重绘回流。
- 回流必将引起重绘，重绘不一定引起回流。

**最小化重绘和回流**

以下几个操作会导致性能问题

- 改变window大小
- 改变字体
- 添加或删除样式
- 文字改变
- 定位或者浮动
- 盒模型

## 如何减少和避免重排

1. 直接改变className，如果动态改变样式，则使用cssText（考虑没有优化的浏览器）；

2. 让要操作的元素进行”离线处理”，处理完后一起更新；

   a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘；
           b) 使用display:none技术，只引发两次回流和重绘；
           c) 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；

   3.不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存；

4. 让元素脱离动画流，减少回流的Render Tree的规模；

# requestIdleCallback有什么用

**`window.requestIdleCallback()`**方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间`timeout`，则有可能为了在超时前执行函数而打乱执行顺序。